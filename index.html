<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARCADE RETRO PRO</title>
    <style>
        /* (Todos los estilos anteriores se mantienen igual) */
    </style>
</head>
<body>
    <!-- (Todo el HTML anterior se mantiene igual) -->

    <script>
        // ==========================================
        // CORRECCIÓN DEL JUEGO COMECOCOS
        // ==========================================
        function initPacman() {
            const canvas = document.getElementById('pacman-canvas');
            const ctx = canvas.getContext('2d');
            const scoreDisplay = document.getElementById('pacman-score');
            
            const gridSize = 20;
            const tileCount = canvas.width / gridSize;
            
            let pacman = {
                x: 10 * gridSize,
                y: 10 * gridSize,
                dx: 0,
                dy: 0,
                nextDx: 0,
                nextDy: 0,
                mouthAngle: 0.2,
                mouthDirection: 1,
                radius: gridSize / 2
            };
            
            let ghosts = [
                { x: 9 * gridSize, y: 9 * gridSize, dx: gridSize, dy: 0, color: '#ff0000' },
                { x: 10 * gridSize, y: 9 * gridSize, dx: -gridSize, dy: 0, color: '#ff00ff' },
                { x: 9 * gridSize, y: 10 * gridSize, dx: 0, dy: gridSize, color: '#00ffff' },
                { x: 10 * gridSize, y: 10 * gridSize, dx: 0, dy: -gridSize, color: '#ffff00' }
            ];
            
            let dots = [];
            let gameInterval;
            
            gameData.pacman.currentScore = 0;
            scoreDisplay.textContent = `Puntos: ${gameData.pacman.currentScore}`;
            
            function createDots() {
                dots = [];
                for (let y = 0; y < tileCount; y++) {
                    for (let x = 0; x < tileCount; x++) {
                        if (!(x >= 8 && x <= 11 && y >= 8 && y <= 11)) {
                            dots.push({
                                x: x * gridSize,
                                y: y * gridSize,
                                isPowerDot: Math.random() < 0.1
                            });
                        }
                    }
                }
            }
            
            function drawPacman() {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                
                let startAngle, endAngle;
                if (pacman.dx > 0) {
                    startAngle = pacman.mouthAngle * Math.PI;
                    endAngle = (2 - pacman.mouthAngle) * Math.PI;
                } else if (pacman.dx < 0) {
                    startAngle = (1 + pacman.mouthAngle) * Math.PI;
                    endAngle = (3 - pacman.mouthAngle) * Math.PI;
                } else if (pacman.dy > 0) {
                    startAngle = (0.5 + pacman.mouthAngle) * Math.PI;
                    endAngle = (2.5 - pacman.mouthAngle) * Math.PI;
                } else {
                    startAngle = (1.5 + pacman.mouthAngle) * Math.PI;
                    endAngle = (3.5 - pacman.mouthAngle) * Math.PI;
                }
                
                ctx.arc(
                    pacman.x + gridSize/2, 
                    pacman.y + gridSize/2, 
                    pacman.radius, 
                    startAngle, 
                    endAngle
                );
                ctx.lineTo(pacman.x + gridSize/2, pacman.y + gridSize/2);
                ctx.fill();
                
                // Ojo
                ctx.fillStyle = 'black';
                ctx.beginPath();
                let eyeX = pacman.x + gridSize/2 + (pacman.dx !== 0 ? (pacman.dx > 0 ? 5 : -5) : 0);
                let eyeY = pacman.y + gridSize/2 + (pacman.dy !== 0 ? (pacman.dy > 0 ? 5 : -5) : -3);
                ctx.arc(eyeX, eyeY, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Animación boca
                pacman.mouthAngle += 0.05 * pacman.mouthDirection;
                if (pacman.mouthAngle >= 0.5 || pacman.mouthAngle <= 0) {
                    pacman.mouthDirection *= -1;
                }
            }
            
            function drawGhosts() {
                ghosts.forEach(ghost => {
                    // Cuerpo fantasma
                    ctx.fillStyle = ghost.color;
                    ctx.beginPath();
                    ctx.arc(
                        ghost.x + gridSize/2, 
                        ghost.y + gridSize/2, 
                        gridSize/2, 
                        Math.PI, 
                        Math.PI * 2
                    );
                    ctx.lineTo(
                        ghost.x + gridSize/2 - gridSize/2, 
                        ghost.y + gridSize/2 + gridSize/2
                    );
                    for (let i = 0; i < 3; i++) {
                        ctx.lineTo(
                            ghost.x + gridSize/2 - gridSize/2 + (gridSize/3 * i),
                            ghost.y + gridSize/2 + gridSize/3
                        );
                        ctx.lineTo(
                            ghost.x + gridSize/2 - gridSize/2 + (gridSize/3 * i) + gridSize/6,
                            ghost.y + gridSize/2 + gridSize/2
                        );
                    }
                    ctx.lineTo(
                        ghost.x + gridSize/2 + gridSize/2, 
                        ghost.y + gridSize/2 + gridSize/2
                    );
                    ctx.closePath();
                    ctx.fill();
                    
                    // Ojos
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(
                        ghost.x + gridSize/2 - 5, 
                        ghost.y + gridSize/2 - 3, 
                        3, 
                        0, 
                        Math.PI * 2
                    );
                    ctx.arc(
                        ghost.x + gridSize/2 + 5, 
                        ghost.y + gridSize/2 - 3, 
                        3, 
                        0, 
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    // Pupilas
                    ctx.fillStyle = 'blue';
                    ctx.beginPath();
                    ctx.arc(
                        ghost.x + gridSize/2 - 5 + (ghost.dx * 0.2), 
                        ghost.y + gridSize/2 - 3 + (ghost.dy * 0.2), 
                        2, 
                        0, 
                        Math.PI * 2
                    );
                    ctx.arc(
                        ghost.x + gridSize/2 + 5 + (ghost.dx * 0.2), 
                        ghost.y + gridSize/2 - 3 + (ghost.dy * 0.2), 
                        2, 
                        0, 
                        Math.PI * 2
                    );
                    ctx.fill();
                });
            }
            
            function drawDots() {
                dots.forEach(dot => {
                    ctx.fillStyle = dot.isPowerDot ? '#ffffff' : '#aaaaaa';
                    ctx.beginPath();
                    ctx.arc(
                        dot.x + gridSize/2, 
                        dot.y + gridSize/2, 
                        dot.isPowerDot ? 6 : 3, 
                        0, 
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    if (dot.isPowerDot) {
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                });
            }
            
            function movePacman() {
                // Aplicar el siguiente movimiento si es válido
                const newX = pacman.x + pacman.nextDx;
                const newY = pacman.y + pacman.nextDy;
                
                if (newX >= 0 && newX < canvas.width && newY >= 0 && newY < canvas.height) {
                    pacman.dx = pacman.nextDx;
                    pacman.dy = pacman.nextDy;
                }
                
                pacman.x += pacman.dx;
                pacman.y += pacman.dy;
                
                // Teletransporte en bordes
                if (pacman.x < 0) pacman.x = canvas.width - gridSize;
                if (pacman.x >= canvas.width) pacman.x = 0;
                if (pacman.y < 0) pacman.y = canvas.height - gridSize;
                if (pacman.y >= canvas.height) pacman.y = 0;
                
                // Comer puntos
                dots = dots.filter(dot => {
                    const distance = Math.sqrt(
                        Math.pow(dot.x + gridSize/2 - (pacman.x + gridSize/2), 2) + 
                        Math.pow(dot.y + gridSize/2 - (pacman.y + gridSize/2), 2)
                    );
                    
                    if (distance < pacman.radius + (dot.isPowerDot ? 6 : 3)) {
                        gameData.pacman.currentScore += dot.isPowerDot ? 50 : 10;
                        scoreDisplay.textContent = `Puntos: ${gameData.pacman.currentScore}`;
                        return false;
                    }
                    return true;
                });
                
                // Verificar si se comieron todos los puntos
                if (dots.length === 0) {
                    clearInterval(gameInterval);
                    if (gameData.pacman.currentScore > gameData.pacman.highScore) {
                        gameData.pacman.highScore = gameData.pacman.currentScore;
                        localStorage.setItem('pacmanHighScore', gameData.pacman.highScore);
                    }
                    alert(`¡Ganaste! Puntos: ${gameData.pacman.currentScore}`);
                    resetPacman();
                }
            }
            
            function moveGhosts() {
                ghosts.forEach(ghost => {
                    // IA simple para los fantasmas
                    const directions = [];
                    if (ghost.x % gridSize === 0 && ghost.y % gridSize === 0) {
                        // Solo cambiar dirección en intersecciones
                        if (ghost.x > 0) directions.push({dx: -gridSize, dy: 0});
                        if (ghost.x < canvas.width - gridSize) directions.push({dx: gridSize, dy: 0});
                        if (ghost.y > 0) directions.push({dx: 0, dy: -gridSize});
                        if (ghost.y < canvas.height - gridSize) directions.push({dx: 0, dy: gridSize});
                        
                        // Eliminar movimiento inverso (para no dar vueltas)
                        directions = directions.filter(dir => 
                            !(dir.dx === -ghost.dx && dir.dy === -ghost.dy));
                        
                        if (directions.length > 0) {
                            const move = directions[Math.floor(Math.random() * directions.length)];
                            ghost.dx = move.dx;
                            ghost.dy = move.dy;
                        }
                    }
                    
                    ghost.x += ghost.dx;
                    ghost.y += ghost.dy;
                    
                    // Teletransporte en bordes
                    if (ghost.x < 0) ghost.x = canvas.width - gridSize;
                    if (ghost.x >= canvas.width) ghost.x = 0;
                    if (ghost.y < 0) ghost.y = canvas.height - gridSize;
                    if (ghost.y >= canvas.height) ghost.y = 0;
                    
                    // Detección de colisión con Pacman
                    const distance = Math.sqrt(
                        Math.pow(ghost.x + gridSize/2 - (pacman.x + gridSize/2), 2) +
                        Math.pow(ghost.y + gridSize/2 - (pacman.y + gridSize/2), 2)
                    );
                    
                    if (distance < gridSize) {
                        clearInterval(gameInterval);
                        if (gameData.pacman.currentScore > gameData.pacman.highScore) {
                            gameData.pacman.highScore = gameData.pacman.currentScore;
                            localStorage.setItem('pacmanHighScore', gameData.pacman.highScore);
                        }
                        alert(`¡Game Over! Puntos: ${gameData.pacman.currentScore}`);
                        resetPacman();
                    }
                });
            }
            
            function clearCanvas() {
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            function gameLoop() {
                clearCanvas();
                drawDots();
                movePacman();
                moveGhosts();
                drawPacman();
                drawGhosts();
            }
            
            function resetPacman() {
                pacman = {
                    x: 10 * gridSize,
                    y: 10 * gridSize,
                    dx: 0,
                    dy: 0,
                    nextDx: 0,
                    nextDy: 0,
                    mouthAngle: 0.2,
                    mouthDirection: 1,
                    radius: gridSize / 2
                };
                
                ghosts = [
                    { x: 9 * gridSize, y: 9 * gridSize, dx: gridSize, dy: 0, color: '#ff0000' },
                    { x: 10 * gridSize, y: 9 * gridSize, dx: -gridSize, dy: 0, color: '#ff00ff' },
                    { x: 9 * gridSize, y: 10 * gridSize, dx: 0, dy: gridSize, color: '#00ffff' },
                    { x: 10 * gridSize, y: 10 * gridSize, dx: 0, dy: -gridSize, color: '#ffff00' }
                ];
                
                gameData.pacman.currentScore = 0;
                scoreDisplay.textContent = `Puntos: ${gameData.pacman.currentScore}`;
                createDots();
                gameInterval = setInterval(gameLoop, 150);
            }
            
            document.addEventListener('keydown', function(event) {
                const key = event.keyCode;
                
                if (key === 37) { // Izquierda
                    pacman.nextDx = -gridSize;
                    pacman.nextDy = 0;
                } else if (key === 38) { // Arriba
                    pacman.nextDx = 0;
                    pacman.nextDy = -gridSize;
                } else if (key === 39) { // Derecha
                    pacman.nextDx = gridSize;
                    pacman.nextDy = 0;
                } else if (key === 40) { // Abajo
                    pacman.nextDx = 0;
                    pacman.nextDy = gridSize;
                }
            });
            
            createDots();
            gameInterval = setInterval(gameLoop, 150);
        }

        // (El resto del código se mantiene igual)
    </script>
</body>
</html>